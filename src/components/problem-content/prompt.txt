I am creating a leetcode-style coding interview preparation platform focused on real-world coding problems. These problems are classified as object-oriented design (OOD) and system design problems with potential algorithmic and data structure twists. I want you to help me create questions for this platform that mimic real interview questions commonly used in software engineering internship/entry level full-time interviews by companies like Amazon, Meta, OpenAI, etc. 

Here are examples of questions we already have: 

problems: - title: "1. Parking Lot" id: "parking-lot" difficulty: "Easy" problem-content: "./ParkingLotContent.tsx" placeholder-code: - language: python code: | class ParkingLot: def __init__(self, big: int, medium: int, small: int): def addCar(self, carType: int) -> bool: # Your ParkingLot object will be instantiated and called as such: # obj = ParkingLot(big, medium, small) # param_1 = obj.addCar(carType) - language: cpp code: | class ParkingLot { public: ParkingLot(int big, int medium, int small) { } bool addCar(int carType) { } }; /** * Your ParkingLot object will be instantiated and called as such: * ParkingLot* obj = new ParkingLot(big, medium, small); * bool param_1 = obj->addCar(carType); */ - language: java code: | class ParkingLot { public ParkingLot(int big, int medium, int small) { } public boolean addCar(int carType) { } } /** * Your ParkingLot object will be instantiated and called as such: * ParkingLot obj = new ParkingLot(big, medium, small); * boolean param_1 = obj.addCar(carType); */ - language: javascript code: | /** * @param {number} big * @param {number} medium * @param {number} small */ var ParkingLot = function(big, medium, small) { }; /** * @param {number} carType * @return {boolean} */ ParkingLot.prototype.addCar = function(carType) { }; /** * Your ParkingLot object will be instantiated and called as such: * var obj = new ParkingLot(big, medium, small) * var param_1 = obj.addCar(carType) */ test-cases: - language: python number: 1 code: | lot = ParkingLot(2, 1, 0) assertEquals(lot.addCar(1), True) assertEquals(lot.addCar(1), True) assertEquals(lot.addCar(1), False) assertEquals(lot.addCar(2), True) assertEquals(lot.addCar(2), False) assertEquals(lot.addCar(3), False) - language: python number: 2 code: | lot = ParkingLot(0, 0, 0) assertEquals(lot.addCar(1), False) assertEquals(lot.addCar(2), False) assertEquals(lot.addCar(3), False) - language: python number: 3 code: | lot = ParkingLot(1, 2, 1) assertEquals(lot.addCar(3), True) assertEquals(lot.addCar(2), True) assertEquals(lot.addCar(1), True) assertEquals(lot.addCar(2), True) assertEquals(lot.addCar(2), False) assertEquals(lot.addCar(3), False) - language: cpp number: 1 code: | ParkingLot* lot = new ParkingLot(2, 1, 0); Printer::assertEquals(lot->addCar(1), true); Printer::assertEquals(lot->addCar(1), true); Printer::assertEquals(lot->addCar(1), false); Printer::assertEquals(lot->addCar(2), true); Printer::assertEquals(lot->addCar(2), false); Printer::assertEquals(lot->addCar(3), false); - language: cpp number: 2 code: | ParkingLot* lot = new ParkingLot(0, 0, 0); Printer::assertEquals(lot->addCar(1), false); Printer::assertEquals(lot->addCar(2), false); Printer::assertEquals(lot->addCar(3), false); - language: cpp number: 3 code: | ParkingLot* lot = new ParkingLot(1, 2, 1); Printer::assertEquals(lot->addCar(3), true); Printer::assertEquals(lot->addCar(2), true); Printer::assertEquals(lot->addCar(1), true); Printer::assertEquals(lot->addCar(2), true); Printer::assertEquals(lot->addCar(2), false); Printer::assertEquals(lot->addCar(3), false); - language: java number: 1 code: | ParkingLot lot = new ParkingLot(2, 1, 0); assertEquals(lot.addCar(1), true); assertEquals(lot.addCar(1), true); assertEquals(lot.addCar(1), false); assertEquals(lot.addCar(2), true); assertEquals(lot.addCar(2), false); assertEquals(lot.addCar(3), false); - language: java number: 2 code: | ParkingLot lot = new ParkingLot(0, 0, 0); assertEquals(lot.addCar(1), false); assertEquals(lot.addCar(2), false); assertEquals(lot.addCar(3), false); - language: java number: 3 code: | ParkingLot lot = new ParkingLot(1, 2, 1); assertEquals(lot.addCar(3), true); assertEquals(lot.addCar(2), true); assertEquals(lot.addCar(1), true); assertEquals(lot.addCar(2), true); assertEquals(lot.addCar(2), false); assertEquals(lot.addCar(3), false); - language: javascript number: 1 code: | var lot = new ParkingLot(2, 1, 0) assertEquals(lot.addCar(1), true); assertEquals(lot.addCar(1), true); assertEquals(lot.addCar(1), false); assertEquals(lot.addCar(2), true); assertEquals(lot.addCar(2), false); assertEquals(lot.addCar(3), false); - language: javascript number: 2 code: | var lot = new ParkingLot(0, 0, 0) assertEquals(lot.addCar(1), false); assertEquals(lot.addCar(2), false); assertEquals(lot.addCar(3), false); - language: javascript number: 3 code: | var lot = new ParkingLot(1, 2, 1) assertEquals(lot.addCar(3), true); assertEquals(lot.addCar(2), true); assertEquals(lot.addCar(1), true); assertEquals(lot.addCar(2), true); assertEquals(lot.addCar(2), false); assertEquals(lot.addCar(3), false); - title: "2. Call Center" id: "call-center" difficulty: "Medium" problem-content: "./CallCenterContent.tsx" placeholder-code: - language: python code: | class CallCenter: def __init__(self, numAgents: int): # Initialize your call center with numAgents agents. # Agents are numbered from 1 to numAgents. pass def dispatchCall(self) -> int: # Dispatch a call to the available agent with the smallest id. # If an agent is available, mark them as busy and return their id. # If no agents are available, return -1. pass def endCall(self, agentId: int) -> None: # Mark the agent with agentId as available. pass # Your CallCenter object will be instantiated and called as such: # obj = CallCenter(numAgents) # param = obj.dispatchCall() # obj.endCall(agentId) - language: cpp code: | class CallCenter { public: CallCenter(int numAgents) { // Initialize your call center with numAgents agents. // Agents are numbered from 1 to numAgents. } int dispatchCall() { // Dispatch a call to the available agent with the smallest id. // If an agent is available, mark them as busy and return their id. // If no agents are available, return -1. } void endCall(int agentId) { // Mark the agent with agentId as available. } }; /** * Your CallCenter object will be instantiated and called as such: * CallCenter* obj = new CallCenter(numAgents); * int param = obj->dispatchCall(); * obj->endCall(agentId); */ - language: java code: | class CallCenter { public CallCenter(int numAgents) { // Initialize your call center with numAgents agents. // Agents are numbered from 1 to numAgents. } public int dispatchCall() { // Dispatch a call to the available agent with the smallest id. // If an agent is available, mark them as busy and return their id. // If no agents are available, return -1. } public void endCall(int agentId) { // Mark the agent with agentId as available. } } /** * Your CallCenter object will be instantiated and called as such: * CallCenter obj = new CallCenter(numAgents); * int param = obj.dispatchCall(); * obj.endCall(agentId); */ - language: javascript code: | /** * @param {number} numAgents */ var CallCenter = function(numAgents) { // Initialize your call center with numAgents agents. // Agents are numbered from 1 to numAgents. }; /** * @return {number} */ CallCenter.prototype.dispatchCall = function() { // Dispatch a call to the available agent with the smallest id. // If an agent is available, mark them as busy and return their id. // If no agents are available, return -1. }; /** * @param {number} agentId */ CallCenter.prototype.endCall = function(agentId) { // Mark the agent with agentId as available. }; /** * Your CallCenter object will be instantiated and called as such: * var obj = new CallCenter(numAgents) * var param = obj.dispatchCall() * obj.endCall(agentId) */ test-cases: - language: python number: 1 code: | center = CallCenter(2) assertEquals(center.dispatchCall(), 1) assertEquals(center.dispatchCall(), 2) assertEquals(center.dispatchCall(), -1) center.endCall(1) assertEquals(center.dispatchCall(), 1) - language: python number: 2 code: | center = CallCenter(1) assertEquals(center.dispatchCall(), 1) assertEquals(center.dispatchCall(), -1) center.endCall(1) assertEquals(center.dispatchCall(), 1) - language: python number: 3 code: | center = CallCenter(3) assertEquals(center.dispatchCall(), 1) assertEquals(center.dispatchCall(), 2) assertEquals(center.dispatchCall(), 3) assertEquals(center.dispatchCall(), -1) center.endCall(2) assertEquals(center.dispatchCall(), 2) - language: cpp number: 1 code: | CallCenter* center = new CallCenter(2); Printer::assertEquals(center->dispatchCall(), 1); Printer::assertEquals(center->dispatchCall(), 2); Printer::assertEquals(center->dispatchCall(), -1); center->endCall(1); Printer::assertEquals(center->dispatchCall(), 1); - language: cpp number: 2 code: | CallCenter* center = new CallCenter(0); Printer::assertEquals(center->dispatchCall(), -1); - language: cpp number: 3 code: | CallCenter* center = new CallCenter(3); Printer::assertEquals(center->dispatchCall(), 1); Printer::assertEquals(center->dispatchCall(), 2); Printer::assertEquals(center->dispatchCall(), 3); Printer::assertEquals(center->dispatchCall(), -1); center->endCall(2); Printer::assertEquals(center->dispatchCall(), 2); - language: java number: 1 code: | CallCenter center = new CallCenter(2); assertEquals(center.dispatchCall(), 1); assertEquals(center.dispatchCall(), 2); assertEquals(center.dispatchCall(), -1); center.endCall(1); assertEquals(center.dispatchCall(), 1); - language: java number: 2 code: | CallCenter center = new CallCenter(0); assertEquals(center.dispatchCall(), -1); - language: java number: 3 code: | CallCenter center = new CallCenter(3); assertEquals(center.dispatchCall(), 1); assertEquals(center.dispatchCall(), 2); assertEquals(center.dispatchCall(), 3); assertEquals(center.dispatchCall(), -1); center.endCall(2); assertEquals(center.dispatchCall(), 2); - language: javascript number: 1 code: | var center = new CallCenter(2) assertEquals(center.dispatchCall(), 1); assertEquals(center.dispatchCall(), 2); assertEquals(center.dispatchCall(), -1); center.endCall(1); assertEquals(center.dispatchCall(), 1); - language: javascript number: 2 code: | var center = new CallCenter(0) assertEquals(center.dispatchCall(), -1); - language: javascript number: 3 code: | var center = new CallCenter(3) assertEquals(center.dispatchCall(), 1); assertEquals(center.dispatchCall(), 2); assertEquals(center.dispatchCall(), 3); assertEquals(center.dispatchCall(), -1); center.endCall(2); assertEquals(center.dispatchCall(), 2); 

Here is an example of a problem's description page:

import React from 'react'; const ParkingLotContent: React.FC = () => { return ( <div className="prose prose-invert max-w-none"> <div> <p className="text-muted-foreground"> Design a Lot for a parking lot with three types of parking spaces: big, medium, and small. The Lot should efficiently manage a fixed number of slots for each size and handle parking requests based on vehicle size. </p> </div> <div className="mt-8"> <h3 className="text-lg font-semibold mb-4">Methods</h3> <div className="space-y-4 text-muted-foreground"> <div> <code className="text-sm">ParkingLot(int big, int medium, int small)</code> <p className="mt-1"> Initializes object of the ParkingLot class. The number of slots for each parking space are given as part of the constructor. </p> </div> <div> <code className="text-sm">bool addCar(int carType)</code> <p className="mt-1"> Checks whether there is a parking space of carType for the car that wants to enter the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true. </p> </div> </div> </div> <div className="mt-8"> <h3 className="text-lg font-semibold mb-4">Example</h3> <pre className="bg-secondary p-4 rounded-md whitespace-pre-wrap break-words overflow-x-auto"> <code> {// Initialize parking Lot with 2 big spots, 2 medium spots, and 1 small spot const parkingLot = new ParkingLot(2, 2, 1); parkingLot.addCar(1); // returns true (parks a big car) parkingLot.addCar(2); // returns true (parks a medium car) parkingLot.addCar(3); // returns true (parks a small car) parkingLot.addCar(1); // returns true (parks another big car) parkingLot.addCar(3); // returns false (no small spots left) parkingLot.addCar(2); // returns true (parks another medium car) parkingLot.addCar(2); // returns false (no medium spots left)} </code> </pre> </div> <div className="mt-8"> <h3 className="text-lg font-semibold mb-4">Constraints</h3> <ul className="space-y-2 text-muted-foreground list-disc pl-4"> <li>0 ≤ big, medium, small ≤ 1000</li> <li>carType is 1, 2, or 3</li> <li>At most 1000 calls will be made to addCar</li> </ul> </div> </div> ); }; export default ParkingLotContent;

Please generate a random question. Here are some requirements that you should follow strictly:

The question should have 4-5 test cases that should test basic, complex, and edge scenarios.
The test cases should not include comments.
The test cases should be deterministic, i.e., no if–else blocks.
The new problem data should be output in a .yaml file formatted EXACTLY like the .yaml file above. 
The new problem description content should be output in a .tsx file formatted EXACTLY like the .tsxl file above.
Please also include a brief (3-4 sentence) written summary of the problem in text form.
Do not copy these example questions verbatim, this new question should be unique.
Make sure the problem mimics real-world coding interview questions of the desired style, and allows the user to practice useful skills.
Ensure the problem is unique and creative! At the end of this prompt, there is a list of current problem summaries. Any new problem should be DIFFERENT from these problems both in theme and technical implementation.
Follow the expected output PRECISELY - do not generate any extra text.

   Expected output:
    [YAML content...]
    ### Problem TSX File
    [TSX file content...]
    ### Problem Description
    [Text description]

Existing problem summaries: